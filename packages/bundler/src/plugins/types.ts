/**
 * @oreo/bundler - Route Type Generation
 *
 * Generates TypeScript types for routes enabling end-to-end type safety.
 */

import { join } from 'node:path';
import type { Route } from '@oreo/core';

/**
 * Route type info.
 */
export interface RouteTypeInfo {
  path: string;
  params: Record<string, 'string' | 'string[]'>;
  hasLoader: boolean;
  hasAction: boolean;
}

/**
 * Extract parameter types from a route path.
 */
export function extractParams(path: string): Record<string, 'string' | 'string[]'> {
  const params: Record<string, 'string' | 'string[]'> = {};
  const segments = path.split('/').filter(Boolean);

  for (const segment of segments) {
    // Catch-all [...param]
    const catchAllMatch = segment.match(/^\[\.\.\.(\w+)\]$/);
    if (catchAllMatch) {
      params[catchAllMatch[1]] = 'string[]';
      continue;
    }

    // Dynamic [param]
    const dynamicMatch = segment.match(/^\[(\w+)\]$/);
    if (dynamicMatch) {
      params[dynamicMatch[1]] = 'string';
      continue;
    }

    // Optional [[param]]
    const optionalMatch = segment.match(/^\[\[(\w+)\]\]$/);
    if (optionalMatch) {
      params[optionalMatch[1]] = 'string';
    }
  }

  return params;
}

/**
 * Generate TypeScript type definitions for routes.
 */
export function generateRouteTypes(routes: Route[]): string {
  const routeInfos: RouteTypeInfo[] = [];

  const collectRoutes = (routeList: Route[]) => {
    for (const route of routeList) {
      if (!route.layout) {
        routeInfos.push({
          path: route.path,
          params: extractParams(route.path),
          hasLoader: !!route.module?.loader,
          hasAction: !!route.module?.action,
        });
      }

      if (route.children) {
        collectRoutes(route.children);
      }
    }
  };

  collectRoutes(routes);

  const lines: string[] = [
    '// Auto-generated by @oreo/bundler',
    '// Do not edit this file manually',
    '',
    "declare module '@oreo/core' {",
    '  export interface RouteTypes {',
  ];

  for (const info of routeInfos) {
    const paramsType = generateParamsType(info.params);
    lines.push(`    '${info.path}': {`);
    lines.push(`      params: ${paramsType};`);
    lines.push(`      loader: unknown; // TODO: infer from loader return type`);
    lines.push(`      action: unknown; // TODO: infer from action return type`);
    lines.push('    };');
  }

  lines.push('  }');
  lines.push('}');
  lines.push('');
  lines.push('export {};');

  return lines.join('\n');
}

/**
 * Generate params type string.
 */
function generateParamsType(params: Record<string, 'string' | 'string[]'>): string {
  const entries = Object.entries(params);

  if (entries.length === 0) {
    return 'Record<string, never>';
  }

  const parts = entries.map(([key, type]) => `${key}: ${type}`);
  return `{ ${parts.join('; ')} }`;
}

/**
 * Write route types to file.
 */
export async function writeRouteTypes(
  outDir: string,
  routes: Route[]
): Promise<void> {
  const types = generateRouteTypes(routes);
  const outPath = join(outDir, 'routes.d.ts');

  await Bun.write(outPath, types);
  console.log(`Route types written to ${outPath}`);
}

/**
 * Create type generation plugin.
 */
export function createTypesPlugin() {
  return {
    name: 'oreo:types',

    async buildEnd() {
      // Types are generated during build
    },
  };
}

/**
 * Generate Link component props types.
 */
export function generateLinkTypes(routes: Route[]): string {
  const paths = routes
    .filter((r) => !r.layout)
    .map((r) => `'${r.path}'`);

  return `
// Auto-generated Link types
import type { ComponentProps } from 'react';

export type AppRoutes = ${paths.join(' | ') || 'string'};

export interface LinkProps extends Omit<ComponentProps<'a'>, 'href'> {
  to: AppRoutes;
  params?: Record<string, string | number>;
  prefetch?: 'hover' | 'viewport' | 'none';
}
  `.trim();
}

/**
 * Generate useLoaderData hook types.
 */
export function generateHookTypes(): string {
  return `
// Auto-generated hook types
import type { RouteTypes } from '@oreo/core';

export function useLoaderData<T extends keyof RouteTypes>(): RouteTypes[T]['loader'];
export function useParams<T extends keyof RouteTypes>(): RouteTypes[T]['params'];
export function useActionData<T extends keyof RouteTypes>(): RouteTypes[T]['action'];
  `.trim();
}
