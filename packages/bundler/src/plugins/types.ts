/**
 * @ereo/bundler - Route Type Generation
 *
 * Generates TypeScript types for routes enabling end-to-end type safety.
 * Infers loader/action types from module exports for full type inference.
 */

import { join } from 'node:path';
import type { Route, RouteModule } from '@ereo/core';

/**
 * Route type info with inferred types.
 */
export interface RouteTypeInfo {
  path: string;
  file: string;
  params: Record<string, ParamType>;
  hasLoader: boolean;
  hasAction: boolean;
  hasMeta: boolean;
  hasHandle: boolean;
  loaderTypeRef?: string;
  actionTypeRef?: string;
  config?: {
    renderMode?: string;
    auth?: boolean;
  };
}

/**
 * Parameter type with optionality.
 */
export interface ParamType {
  type: 'string' | 'string[]';
  optional?: boolean;
}

/**
 * Extract parameter types from a route path with optionality.
 */
export function extractParams(path: string): Record<string, ParamType> {
  const params: Record<string, ParamType> = {};
  const segments = path.split('/').filter(Boolean);

  for (const segment of segments) {
    // Catch-all [...param]
    const catchAllMatch = segment.match(/^\[\.\.\.(\w+)\]$/);
    if (catchAllMatch) {
      params[catchAllMatch[1]] = { type: 'string[]' };
      continue;
    }

    // Optional [[param]]
    const optionalMatch = segment.match(/^\[\[(\w+)\]\]$/);
    if (optionalMatch) {
      params[optionalMatch[1]] = { type: 'string', optional: true };
      continue;
    }

    // Dynamic [param]
    const dynamicMatch = segment.match(/^\[(\w+)\]$/);
    if (dynamicMatch) {
      params[dynamicMatch[1]] = { type: 'string' };
      continue;
    }
  }

  return params;
}

/**
 * Generate import path from file path.
 */
function generateImportPath(file: string, routesDir: string): string {
  // Convert file path to import path
  let importPath = file
    .replace(routesDir, '@routes')
    .replace(/\.(tsx?|jsx?)$/, '');

  return importPath;
}

/**
 * Generate TypeScript type definitions for routes with full inference.
 */
export function generateRouteTypes(
  routes: Route[],
  options: {
    routesDir?: string;
    inferTypes?: boolean;
  } = {}
): string {
  const { routesDir = 'app/routes', inferTypes = true } = options;
  const routeInfos: RouteTypeInfo[] = [];

  const collectRoutes = (routeList: Route[], parentPath = '') => {
    for (const route of routeList) {
      if (!route.layout) {
        const info: RouteTypeInfo = {
          path: route.path,
          file: route.file,
          params: extractParams(route.path),
          hasLoader: !!route.module?.loader,
          hasAction: !!route.module?.action,
          hasMeta: !!route.module?.meta,
          hasHandle: !!route.module?.handle,
          config: {
            renderMode: route.config?.render?.mode,
            auth: route.config?.auth?.required,
          },
        };

        // Generate type references for inference
        if (inferTypes) {
          const importPath = generateImportPath(route.file, routesDir);
          if (info.hasLoader) {
            info.loaderTypeRef = `typeof import('${importPath}')['loader']`;
          }
          if (info.hasAction) {
            info.actionTypeRef = `typeof import('${importPath}')['action']`;
          }
        }

        routeInfos.push(info);
      }

      if (route.children) {
        collectRoutes(route.children, route.path);
      }
    }
  };

  collectRoutes(routes);

  const lines: string[] = [
    '// Auto-generated by @ereo/bundler',
    '// Do not edit this file manually',
    '// Generated at: ' + new Date().toISOString(),
    '',
  ];

  // Generate imports for type inference
  if (inferTypes) {
    lines.push('// Route module imports for type inference');
    const uniqueImports = new Set<string>();

    for (const info of routeInfos) {
      const importPath = generateImportPath(info.file, routesDir);
      if (!uniqueImports.has(importPath)) {
        uniqueImports.add(importPath);
        const safeName = importPath.replace(/[^a-zA-Z0-9]/g, '_');
        lines.push(`import type * as ${safeName} from '${importPath}';`);
      }
    }
    lines.push('');
  }

  // Module augmentation for RouteTypes
  lines.push("declare module '@ereo/core' {");
  lines.push('  export interface RouteTypes {');

  for (const info of routeInfos) {
    const paramsType = generateParamsType(info.params);
    const importPath = generateImportPath(info.file, routesDir);
    const safeName = importPath.replace(/[^a-zA-Z0-9]/g, '_');

    lines.push(`    '${info.path}': {`);
    lines.push(`      params: ${paramsType};`);

    // Loader type inference
    if (info.hasLoader && inferTypes) {
      lines.push(`      loader: ${safeName} extends { loader: infer L } ? (L extends (...args: any[]) => infer R ? Awaited<R> : never) : never;`);
    } else {
      lines.push(`      loader: unknown;`);
    }

    // Action type inference
    if (info.hasAction && inferTypes) {
      lines.push(`      action: ${safeName} extends { action: infer A } ? (A extends (...args: any[]) => infer R ? Awaited<R> : never) : never;`);
    } else {
      lines.push(`      action: unknown;`);
    }

    // Additional metadata
    lines.push(`      meta: ${info.hasMeta};`);
    lines.push(`      handle: ${info.hasHandle ? `${safeName}['handle']` : 'undefined'};`);

    lines.push('    };');
  }

  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Generate route path type
  lines.push('// All available route paths');
  const paths = routeInfos.map((r) => `'${r.path}'`);
  lines.push(`export type RoutePath = ${paths.join(' | ') || 'never'};`);
  lines.push('');

  // Generate helper types
  lines.push('// Helper types for route-safe navigation');
  lines.push(`
/**
 * Extract params type for a route path.
 */
export type ParamsFor<T extends RoutePath> =
  T extends keyof import('@ereo/core').RouteTypes
    ? import('@ereo/core').RouteTypes[T]['params']
    : Record<string, string>;

/**
 * Extract loader data type for a route path.
 */
export type LoaderDataFor<T extends RoutePath> =
  T extends keyof import('@ereo/core').RouteTypes
    ? import('@ereo/core').RouteTypes[T]['loader']
    : unknown;

/**
 * Extract action data type for a route path.
 */
export type ActionDataFor<T extends RoutePath> =
  T extends keyof import('@ereo/core').RouteTypes
    ? import('@ereo/core').RouteTypes[T]['action']
    : unknown;

/**
 * Type-safe route with params.
 */
export type TypedRoute<T extends RoutePath> = {
  path: T;
  params: ParamsFor<T>;
};

/**
 * Build a URL path with params.
 */
export function buildPath<T extends RoutePath>(
  path: T,
  params: ParamsFor<T>
): string {
  let result: string = path;
  for (const [key, value] of Object.entries(params as Record<string, string>)) {
    result = result.replace(\`[\${key}]\`, value);
    result = result.replace(\`[[\${key}]]\`, value || '');
    result = result.replace(\`[...\${key}]\`, Array.isArray(value) ? value.join('/') : value);
  }
  return result;
}
`.trim());

  lines.push('');
  lines.push('export {};');

  return lines.join('\n');
}

/**
 * Generate params type string with optionality.
 */
function generateParamsType(params: Record<string, ParamType>): string {
  const entries = Object.entries(params);

  if (entries.length === 0) {
    return 'Record<string, never>';
  }

  const parts = entries.map(([key, { type, optional }]) => {
    const optionalMark = optional ? '?' : '';
    return `${key}${optionalMark}: ${type}`;
  });

  return `{ ${parts.join('; ')} }`;
}

/**
 * Write route types to file.
 */
export async function writeRouteTypes(
  outDir: string,
  routes: Route[],
  options: { routesDir?: string; inferTypes?: boolean } = {}
): Promise<void> {
  const types = generateRouteTypes(routes, options);
  const outPath = join(outDir, 'routes.d.ts');

  await Bun.write(outPath, types);
  console.log(`\x1b[32m✓\x1b[0m Route types written to ${outPath}`);
}

/**
 * Create type generation plugin.
 */
export function createTypesPlugin(options: {
  outDir?: string;
  routesDir?: string;
  inferTypes?: boolean;
  watch?: boolean;
} = {}) {
  const { outDir = '.ereo', routesDir = 'app/routes', inferTypes = true, watch = false } = options;
  let routes: Route[] = [];

  return {
    name: 'ereo:types',

    transformRoutes(routeList: Route[]) {
      routes = routeList;
      return routeList;
    },

    async buildEnd() {
      if (routes.length > 0) {
        await writeRouteTypes(outDir, routes, { routesDir, inferTypes });
      }
    },

    async configureServer(server: { middlewares: unknown[] }) {
      // Regenerate types on route changes in dev mode
      if (watch) {
        // Types are regenerated when routes reload
      }
    },
  };
}

/**
 * Generate Link component props types.
 */
export function generateLinkTypes(routes: Route[]): string {
  const routeInfos = routes
    .filter((r) => !r.layout)
    .map((r) => ({
      path: r.path,
      params: extractParams(r.path),
    }));

  const pathTypes = routeInfos.map((r) => `'${r.path}'`);

  return `
// Auto-generated Link types
import type { ComponentProps, ReactNode } from 'react';
import type { RoutePath, ParamsFor } from './routes';

/**
 * Type-safe Link component props.
 */
export interface LinkProps<T extends RoutePath = RoutePath>
  extends Omit<ComponentProps<'a'>, 'href'> {
  /** Route path to navigate to */
  to: T;
  /** Route parameters (type-safe based on route) */
  params?: ParamsFor<T>;
  /** Prefetch strategy */
  prefetch?: 'hover' | 'viewport' | 'none';
  /** Replace current history entry */
  replace?: boolean;
  /** Scroll to top on navigation */
  scroll?: boolean;
  /** Children */
  children?: ReactNode;
}

/**
 * All available routes.
 */
export type AppRoutes = ${pathTypes.join(' | ') || 'string'};
  `.trim();
}

/**
 * Generate useLoaderData hook types.
 */
export function generateHookTypes(): string {
  return `
// Auto-generated hook types
import type { RouteTypes, RoutePath, LoaderDataFor, ActionDataFor, ParamsFor } from './routes';

/**
 * Get loader data for the current route (type-safe).
 *
 * @example
 * // In /blog/[slug].tsx
 * const { post, comments } = useLoaderData<'/blog/[slug]'>();
 * //      ^? { post: Post, comments: Comment[] }
 */
export declare function useLoaderData<T extends RoutePath>(): LoaderDataFor<T>;

/**
 * Get route params for the current route (type-safe).
 *
 * @example
 * // In /blog/[slug].tsx
 * const { slug } = useParams<'/blog/[slug]'>();
 * //      ^? string
 */
export declare function useParams<T extends RoutePath>(): ParamsFor<T>;

/**
 * Get action data for the current route (type-safe).
 *
 * @example
 * // In /blog/[slug].tsx
 * const actionData = useActionData<'/blog/[slug]'>();
 */
export declare function useActionData<T extends RoutePath>(): ActionDataFor<T> | undefined;

/**
 * Get route matches with typed data.
 */
export declare function useMatches<T extends RoutePath>(): Array<{
  id: string;
  pathname: string;
  params: ParamsFor<T>;
  data: LoaderDataFor<T>;
  handle: RouteTypes[T]['handle'];
}>;

/**
 * Navigation hook with type-safe paths.
 */
export declare function useNavigate(): {
  <T extends RoutePath>(to: T, options?: {
    params?: ParamsFor<T>;
    replace?: boolean;
    state?: unknown;
  }): void;
  (delta: number): void;
};
  `.trim();
}

/**
 * Generate all type files for a routes directory.
 */
export async function generateAllTypes(
  routes: Route[],
  outDir: string,
  routesDir: string
): Promise<void> {
  // Generate main route types
  await writeRouteTypes(outDir, routes, { routesDir, inferTypes: true });

  // Generate Link types
  const linkTypes = generateLinkTypes(routes);
  await Bun.write(join(outDir, 'link.d.ts'), linkTypes);

  // Generate hook types
  const hookTypes = generateHookTypes();
  await Bun.write(join(outDir, 'hooks.d.ts'), hookTypes);

  // Generate index file that re-exports everything
  const indexContent = `
// Auto-generated by @ereo/bundler
export * from './routes';
export * from './link';
export * from './hooks';
`.trim();
  await Bun.write(join(outDir, 'index.d.ts'), indexContent);

  console.log(`\x1b[32m✓\x1b[0m Generated all type files in ${outDir}`);
}
